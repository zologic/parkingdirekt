"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var chunk_M5NKJZ76_exports = {};
__export(chunk_M5NKJZ76_exports, {
  jestConsoleContext: () => jestConsoleContext,
  jestContext: () => jestContext,
  jestProcessContext: () => jestProcessContext
});
module.exports = __toCommonJS(chunk_M5NKJZ76_exports);
var import_chunk_2ESYSVXG = require("./chunk-2ESYSVXG.js");
var import_path = __toESM(require("path"));
var require_windows = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports, module2) {
    "use strict";
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = (0, import_chunk_2ESYSVXG.__require)("fs");
    function checkPathExt(path2, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path2.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path2, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path2, options);
    }
    function isexe(path2, options, cb) {
      fs2.stat(path2, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path2, options));
      });
    }
    function sync(path2, options) {
      return checkStat(fs2.statSync(path2), path2, options);
    }
  }
});
var require_mode = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports, module2) {
    "use strict";
    module2.exports = isexe;
    isexe.sync = sync;
    var fs2 = (0, import_chunk_2ESYSVXG.__require)("fs");
    function isexe(path2, options, cb) {
      fs2.stat(path2, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path2, options) {
      return checkStat(fs2.statSync(path2), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});
var require_isexe = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports, module2) {
    "use strict";
    var fs2 = (0, import_chunk_2ESYSVXG.__require)("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path2, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve, reject) {
          isexe(path2, options || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve(is);
            }
          });
        });
      }
      core(path2, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path2, options) {
      try {
        return core.sync(path2, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});
var require_which = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js"(exports, module2) {
    "use strict";
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path2 = (0, import_chunk_2ESYSVXG.__require)("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve, reject) => {
        if (ii === pathExt.length)
          return resolve(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve(p + ext);
          }
          return resolve(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path2.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which;
    which.sync = whichSync;
  }
});
var require_path_key = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js"(exports, module2) {
    "use strict";
    var pathKey = (options = {}) => {
      const environment = options.env || process.env;
      const platform = options.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    module2.exports = pathKey;
    module2.exports.default = pathKey;
  }
});
var require_resolveCommand = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports, module2) {
    "use strict";
    var path2 = (0, import_chunk_2ESYSVXG.__require)("path");
    var which = require_which();
    var getPathKey = require_path_key();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const env = parsed.options.env || process.env;
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
      if (shouldSwitchCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: env[getPathKey({ env })],
          pathExt: withoutPathExt ? path2.delimiter : void 0
        });
      } catch (e) {
      } finally {
        if (shouldSwitchCwd) {
          process.chdir(cwd);
        }
      }
      if (resolved) {
        resolved = path2.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  }
});
var require_escape = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js"(exports, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});
var require_shebang_regex = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = /^#!(.*)/;
  }
});
var require_shebang_command = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js"(exports, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = (string = "") => {
      const match = string.match(shebangRegex);
      if (!match) {
        return null;
      }
      const [path2, argument] = match[0].replace(/#! ?/, "").split(" ");
      const binary = path2.split("/").pop();
      if (binary === "env") {
        return argument;
      }
      return argument ? `${binary} ${argument}` : binary;
    };
  }
});
var require_readShebang = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js"(exports, module2) {
    "use strict";
    var fs2 = (0, import_chunk_2ESYSVXG.__require)("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      const buffer = Buffer.alloc(size);
      let fd;
      try {
        fd = fs2.openSync(command, "r");
        fs2.readSync(fd, buffer, 0, size, 0);
        fs2.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});
var require_parse = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js"(exports, module2) {
    "use strict";
    var path2 = (0, import_chunk_2ESYSVXG.__require)("path");
    var resolveCommand = require_resolveCommand();
    var escape = require_escape();
    var readShebang = require_readShebang();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path2.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parse(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parsed : parseNonShell(parsed);
    }
    module2.exports = parse;
  }
});
var require_enoent = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js"(exports, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});
var require_cross_spawn = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js"(exports, module2) {
    "use strict";
    var cp = (0, import_chunk_2ESYSVXG.__require)("child_process");
    var parse = require_parse();
    var enoent = require_enoent();
    function spawn(command, args, options) {
      const parsed = parse(command, args, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      const parsed = parse(command, args, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse;
    module2.exports._enoent = enoent;
  }
});
var require_strip_final_newline = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/strip-final-newline@2.0.0/node_modules/strip-final-newline/index.js"(exports, module2) {
    "use strict";
    module2.exports = (input) => {
      const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
      const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
      if (input[input.length - 1] === LF) {
        input = input.slice(0, input.length - 1);
      }
      if (input[input.length - 1] === CR) {
        input = input.slice(0, input.length - 1);
      }
      return input;
    };
  }
});
var require_npm_run_path = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/npm-run-path@4.0.1/node_modules/npm-run-path/index.js"(exports, module2) {
    "use strict";
    var path2 = (0, import_chunk_2ESYSVXG.__require)("path");
    var pathKey = require_path_key();
    var npmRunPath = (options) => {
      options = {
        cwd: process.cwd(),
        path: process.env[pathKey()],
        execPath: process.execPath,
        ...options
      };
      let previous;
      let cwdPath = path2.resolve(options.cwd);
      const result = [];
      while (previous !== cwdPath) {
        result.push(path2.join(cwdPath, "node_modules/.bin"));
        previous = cwdPath;
        cwdPath = path2.resolve(cwdPath, "..");
      }
      const execPathDir = path2.resolve(options.cwd, options.execPath, "..");
      result.push(execPathDir);
      return result.concat(options.path).join(path2.delimiter);
    };
    module2.exports = npmRunPath;
    module2.exports.default = npmRunPath;
    module2.exports.env = (options) => {
      options = {
        env: process.env,
        ...options
      };
      const env = { ...options.env };
      const path3 = pathKey({ env });
      options.path = env[path3];
      env[path3] = module2.exports(options);
      return env;
    };
  }
});
var require_mimic_fn = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js"(exports, module2) {
    "use strict";
    var mimicFn = (to, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  }
});
var require_onetime = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js"(exports, module2) {
    "use strict";
    var mimicFn = require_mimic_fn();
    var calledFunctions = /* @__PURE__ */ new WeakMap();
    var onetime = (function_, options = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime2 = function(...arguments_) {
        calledFunctions.set(onetime2, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFn(onetime2, function_);
      calledFunctions.set(onetime2, callCount);
      return onetime2;
    };
    module2.exports = onetime;
    module2.exports.default = onetime;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
  }
});
var require_core = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SIGNALS = void 0;
    var SIGNALS = [
      {
        name: "SIGHUP",
        number: 1,
        action: "terminate",
        description: "Terminal closed",
        standard: "posix"
      },
      {
        name: "SIGINT",
        number: 2,
        action: "terminate",
        description: "User interruption with CTRL-C",
        standard: "ansi"
      },
      {
        name: "SIGQUIT",
        number: 3,
        action: "core",
        description: "User interruption with CTRL-\\",
        standard: "posix"
      },
      {
        name: "SIGILL",
        number: 4,
        action: "core",
        description: "Invalid machine instruction",
        standard: "ansi"
      },
      {
        name: "SIGTRAP",
        number: 5,
        action: "core",
        description: "Debugger breakpoint",
        standard: "posix"
      },
      {
        name: "SIGABRT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "ansi"
      },
      {
        name: "SIGIOT",
        number: 6,
        action: "core",
        description: "Aborted",
        standard: "bsd"
      },
      {
        name: "SIGBUS",
        number: 7,
        action: "core",
        description: "Bus error due to misaligned, non-existing address or paging error",
        standard: "bsd"
      },
      {
        name: "SIGEMT",
        number: 7,
        action: "terminate",
        description: "Command should be emulated but is not implemented",
        standard: "other"
      },
      {
        name: "SIGFPE",
        number: 8,
        action: "core",
        description: "Floating point arithmetic error",
        standard: "ansi"
      },
      {
        name: "SIGKILL",
        number: 9,
        action: "terminate",
        description: "Forced termination",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGUSR1",
        number: 10,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGSEGV",
        number: 11,
        action: "core",
        description: "Segmentation fault",
        standard: "ansi"
      },
      {
        name: "SIGUSR2",
        number: 12,
        action: "terminate",
        description: "Application-specific signal",
        standard: "posix"
      },
      {
        name: "SIGPIPE",
        number: 13,
        action: "terminate",
        description: "Broken pipe or socket",
        standard: "posix"
      },
      {
        name: "SIGALRM",
        number: 14,
        action: "terminate",
        description: "Timeout or timer",
        standard: "posix"
      },
      {
        name: "SIGTERM",
        number: 15,
        action: "terminate",
        description: "Termination",
        standard: "ansi"
      },
      {
        name: "SIGSTKFLT",
        number: 16,
        action: "terminate",
        description: "Stack is empty or overflowed",
        standard: "other"
      },
      {
        name: "SIGCHLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "posix"
      },
      {
        name: "SIGCLD",
        number: 17,
        action: "ignore",
        description: "Child process terminated, paused or unpaused",
        standard: "other"
      },
      {
        name: "SIGCONT",
        number: 18,
        action: "unpause",
        description: "Unpaused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGSTOP",
        number: 19,
        action: "pause",
        description: "Paused",
        standard: "posix",
        forced: true
      },
      {
        name: "SIGTSTP",
        number: 20,
        action: "pause",
        description: 'Paused using CTRL-Z or "suspend"',
        standard: "posix"
      },
      {
        name: "SIGTTIN",
        number: 21,
        action: "pause",
        description: "Background process cannot read terminal input",
        standard: "posix"
      },
      {
        name: "SIGBREAK",
        number: 21,
        action: "terminate",
        description: "User interruption with CTRL-BREAK",
        standard: "other"
      },
      {
        name: "SIGTTOU",
        number: 22,
        action: "pause",
        description: "Background process cannot write to terminal output",
        standard: "posix"
      },
      {
        name: "SIGURG",
        number: 23,
        action: "ignore",
        description: "Socket received out-of-band data",
        standard: "bsd"
      },
      {
        name: "SIGXCPU",
        number: 24,
        action: "core",
        description: "Process timed out",
        standard: "bsd"
      },
      {
        name: "SIGXFSZ",
        number: 25,
        action: "core",
        description: "File too big",
        standard: "bsd"
      },
      {
        name: "SIGVTALRM",
        number: 26,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGPROF",
        number: 27,
        action: "terminate",
        description: "Timeout or timer",
        standard: "bsd"
      },
      {
        name: "SIGWINCH",
        number: 28,
        action: "ignore",
        description: "Terminal window size changed",
        standard: "bsd"
      },
      {
        name: "SIGIO",
        number: 29,
        action: "terminate",
        description: "I/O is available",
        standard: "other"
      },
      {
        name: "SIGPOLL",
        number: 29,
        action: "terminate",
        description: "Watched event",
        standard: "other"
      },
      {
        name: "SIGINFO",
        number: 29,
        action: "ignore",
        description: "Request for process information",
        standard: "other"
      },
      {
        name: "SIGPWR",
        number: 30,
        action: "terminate",
        description: "Device running out of power",
        standard: "systemv"
      },
      {
        name: "SIGSYS",
        number: 31,
        action: "core",
        description: "Invalid system call",
        standard: "other"
      },
      {
        name: "SIGUNUSED",
        number: 31,
        action: "terminate",
        description: "Invalid system call",
        standard: "other"
      }
    ];
    exports.SIGNALS = SIGNALS;
  }
});
var require_realtime = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SIGRTMAX = exports.getRealtimeSignals = void 0;
    var getRealtimeSignals = function() {
      const length = SIGRTMAX - SIGRTMIN + 1;
      return Array.from({ length }, getRealtimeSignal);
    };
    exports.getRealtimeSignals = getRealtimeSignals;
    var getRealtimeSignal = function(value, index) {
      return {
        name: `SIGRT${index + 1}`,
        number: SIGRTMIN + index,
        action: "terminate",
        description: "Application-specific signal (realtime)",
        standard: "posix"
      };
    };
    var SIGRTMIN = 34;
    var SIGRTMAX = 64;
    exports.SIGRTMAX = SIGRTMAX;
  }
});
var require_signals = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSignals = void 0;
    var _os = (0, import_chunk_2ESYSVXG.__require)("os");
    var _core = require_core();
    var _realtime = require_realtime();
    var getSignals = function() {
      const realtimeSignals = (0, _realtime.getRealtimeSignals)();
      const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal);
      return signals;
    };
    exports.getSignals = getSignals;
    var normalizeSignal = function({
      name,
      number: defaultNumber,
      description,
      action,
      forced = false,
      standard
    }) {
      const {
        signals: { [name]: constantSignal }
      } = _os.constants;
      const supported = constantSignal !== void 0;
      const number = supported ? constantSignal : defaultNumber;
      return { name, number, description, supported, action, forced, standard };
    };
  }
});
var require_main = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signalsByNumber = exports.signalsByName = void 0;
    var _os = (0, import_chunk_2ESYSVXG.__require)("os");
    var _signals = require_signals();
    var _realtime = require_realtime();
    var getSignalsByName = function() {
      const signals = (0, _signals.getSignals)();
      return signals.reduce(getSignalByName, {});
    };
    var getSignalByName = function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {
      return {
        ...signalByNameMemo,
        [name]: { name, number, description, supported, action, forced, standard }
      };
    };
    var signalsByName = getSignalsByName();
    exports.signalsByName = signalsByName;
    var getSignalsByNumber = function() {
      const signals = (0, _signals.getSignals)();
      const length = _realtime.SIGRTMAX + 1;
      const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
      return Object.assign({}, ...signalsA);
    };
    var getSignalByNumber = function(number, signals) {
      const signal = findSignalByNumber(number, signals);
      if (signal === void 0) {
        return {};
      }
      const { name, description, supported, action, forced, standard } = signal;
      return {
        [number]: {
          name,
          number,
          description,
          supported,
          action,
          forced,
          standard
        }
      };
    };
    var findSignalByNumber = function(number, signals) {
      const signal = signals.find(({ name }) => _os.constants.signals[name] === number);
      if (signal !== void 0) {
        return signal;
      }
      return signals.find((signalA) => signalA.number === number);
    };
    var signalsByNumber = getSignalsByNumber();
    exports.signalsByNumber = signalsByNumber;
  }
});
var require_error = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/error.js"(exports, module2) {
    "use strict";
    var { signalsByName } = require_main();
    var getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
      if (timedOut) {
        return `timed out after ${timeout} milliseconds`;
      }
      if (isCanceled) {
        return "was canceled";
      }
      if (errorCode !== void 0) {
        return `failed with ${errorCode}`;
      }
      if (signal !== void 0) {
        return `was killed with ${signal} (${signalDescription})`;
      }
      if (exitCode !== void 0) {
        return `failed with exit code ${exitCode}`;
      }
      return "failed";
    };
    var makeError = ({
      stdout,
      stderr,
      all,
      error,
      signal,
      exitCode,
      command,
      escapedCommand,
      timedOut,
      isCanceled,
      killed,
      parsed: { options: { timeout } }
    }) => {
      exitCode = exitCode === null ? void 0 : exitCode;
      signal = signal === null ? void 0 : signal;
      const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
      const errorCode = error && error.code;
      const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
      const execaMessage = `Command ${prefix}: ${command}`;
      const isError = Object.prototype.toString.call(error) === "[object Error]";
      const shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage;
      const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
      if (isError) {
        error.originalMessage = error.message;
        error.message = message;
      } else {
        error = new Error(message);
      }
      error.shortMessage = shortMessage;
      error.command = command;
      error.escapedCommand = escapedCommand;
      error.exitCode = exitCode;
      error.signal = signal;
      error.signalDescription = signalDescription;
      error.stdout = stdout;
      error.stderr = stderr;
      if (all !== void 0) {
        error.all = all;
      }
      if ("bufferedData" in error) {
        delete error.bufferedData;
      }
      error.failed = true;
      error.timedOut = Boolean(timedOut);
      error.isCanceled = isCanceled;
      error.killed = killed && !timedOut;
      return error;
    };
    module2.exports = makeError;
  }
});
var require_stdio = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stdio.js"(exports, module2) {
    "use strict";
    var aliases = ["stdin", "stdout", "stderr"];
    var hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);
    var normalizeStdio = (options) => {
      if (!options) {
        return;
      }
      const { stdio } = options;
      if (stdio === void 0) {
        return aliases.map((alias) => options[alias]);
      }
      if (hasAlias(options)) {
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
      }
      if (typeof stdio === "string") {
        return stdio;
      }
      if (!Array.isArray(stdio)) {
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      }
      const length = Math.max(stdio.length, aliases.length);
      return Array.from({ length }, (value, index) => stdio[index]);
    };
    module2.exports = normalizeStdio;
    module2.exports.node = (options) => {
      const stdio = normalizeStdio(options);
      if (stdio === "ipc") {
        return "ipc";
      }
      if (stdio === void 0 || typeof stdio === "string") {
        return [stdio, stdio, stdio, "ipc"];
      }
      if (stdio.includes("ipc")) {
        return stdio;
      }
      return [...stdio, "ipc"];
    };
  }
});
var require_signals2 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js"(exports, module2) {
    "use strict";
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});
var require_signal_exit = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js"(exports, module2) {
    "use strict";
    var process2 = global.process;
    var processOk = function(process3) {
      return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    };
    if (!processOk(process2)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert = (0, import_chunk_2ESYSVXG.__require)("assert");
      signals = require_signals2();
      isWin = /^win/i.test(process2.platform);
      EE = (0, import_chunk_2ESYSVXG.__require)("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process2.__signal_exit_emitter__) {
        emitter = process2.__signal_exit_emitter__;
      } else {
        emitter = process2.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process2.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process2.emit = originalProcessEmit;
        process2.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process2.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process2.kill(process2.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process2.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process2.emit = processEmit;
        process2.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process2.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process2.exitCode = code || /* istanbul ignore next */
        0;
        emit("exit", process2.exitCode, null);
        emit("afterexit", process2.exitCode, null);
        originalProcessReallyExit.call(process2, process2.exitCode);
      };
      originalProcessEmit = process2.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process2.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process2.exitCode, null);
          emit("afterexit", process2.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});
var require_kill = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/kill.js"(exports, module2) {
    "use strict";
    var os = (0, import_chunk_2ESYSVXG.__require)("os");
    var onExit = require_signal_exit();
    var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
    var spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
      const killResult = kill(signal);
      setKillTimeout(kill, signal, options, killResult);
      return killResult;
    };
    var setKillTimeout = (kill, signal, options, killResult) => {
      if (!shouldForceKill(signal, options, killResult)) {
        return;
      }
      const timeout = getForceKillAfterTimeout(options);
      const t = setTimeout(() => {
        kill("SIGKILL");
      }, timeout);
      if (t.unref) {
        t.unref();
      }
    };
    var shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => {
      return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
    };
    var isSigterm = (signal) => {
      return signal === os.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
    };
    var getForceKillAfterTimeout = ({ forceKillAfterTimeout = true }) => {
      if (forceKillAfterTimeout === true) {
        return DEFAULT_FORCE_KILL_TIMEOUT;
      }
      if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
        throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
      }
      return forceKillAfterTimeout;
    };
    var spawnedCancel = (spawned, context) => {
      const killResult = spawned.kill();
      if (killResult) {
        context.isCanceled = true;
      }
    };
    var timeoutKill = (spawned, signal, reject) => {
      spawned.kill(signal);
      reject(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
    };
    var setupTimeout = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
      if (timeout === 0 || timeout === void 0) {
        return spawnedPromise;
      }
      let timeoutId;
      const timeoutPromise = new Promise((resolve, reject) => {
        timeoutId = setTimeout(() => {
          timeoutKill(spawned, killSignal, reject);
        }, timeout);
      });
      const safeSpawnedPromise = spawnedPromise.finally(() => {
        clearTimeout(timeoutId);
      });
      return Promise.race([timeoutPromise, safeSpawnedPromise]);
    };
    var validateTimeout = ({ timeout }) => {
      if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
        throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
      }
    };
    var setExitHandler = async (spawned, { cleanup, detached }, timedPromise) => {
      if (!cleanup || detached) {
        return timedPromise;
      }
      const removeExitHandler = onExit(() => {
        spawned.kill();
      });
      return timedPromise.finally(() => {
        removeExitHandler();
      });
    };
    module2.exports = {
      spawnedKill,
      spawnedCancel,
      setupTimeout,
      validateTimeout,
      setExitHandler
    };
  }
});
var require_is_stream = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/is-stream@2.0.1/node_modules/is-stream/index.js"(exports, module2) {
    "use strict";
    var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module2.exports = isStream;
  }
});
var require_buffer_stream = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js"(exports, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = (0, import_chunk_2ESYSVXG.__require)("stream");
    module2.exports = (options) => {
      options = { ...options };
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});
var require_get_stream = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js"(exports, module2) {
    "use strict";
    var { constants: BufferConstants } = (0, import_chunk_2ESYSVXG.__require)("buffer");
    var stream = (0, import_chunk_2ESYSVXG.__require)("stream");
    var { promisify } = (0, import_chunk_2ESYSVXG.__require)("util");
    var bufferStream = require_buffer_stream();
    var streamPipelinePromisified = promisify(stream.pipeline);
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        throw new Error("Expected a stream");
      }
      options = {
        maxBuffer: Infinity,
        ...options
      };
      const { maxBuffer } = options;
      const stream2 = bufferStream(options);
      await new Promise((resolve, reject) => {
        const rejectPromise = (error) => {
          if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error.bufferedData = stream2.getBufferedValue();
          }
          reject(error);
        };
        (async () => {
          try {
            await streamPipelinePromisified(inputStream, stream2);
            resolve();
          } catch (error) {
            rejectPromise(error);
          }
        })();
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream2.getBufferedValue();
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream2, options) => getStream(stream2, { ...options, encoding: "buffer" });
    module2.exports.array = (stream2, options) => getStream(stream2, { ...options, array: true });
    module2.exports.MaxBufferError = MaxBufferError;
  }
});
var require_merge_stream = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js"(exports, module2) {
    "use strict";
    var { PassThrough } = (0, import_chunk_2ESYSVXG.__require)("stream");
    module2.exports = function() {
      var sources = [];
      var output = new PassThrough({ objectMode: true });
      output.setMaxListeners(0);
      output.add = add;
      output.isEmpty = isEmpty;
      output.on("unpipe", remove);
      Array.prototype.slice.call(arguments).forEach(add);
      return output;
      function add(source) {
        if (Array.isArray(source)) {
          source.forEach(add);
          return this;
        }
        sources.push(source);
        source.once("end", remove.bind(null, source));
        source.once("error", output.emit.bind(output, "error"));
        source.pipe(output, { end: false });
        return this;
      }
      function isEmpty() {
        return sources.length == 0;
      }
      function remove(source) {
        sources = sources.filter(function(it) {
          return it !== source;
        });
        if (!sources.length && output.readable) {
          output.end();
        }
      }
    };
  }
});
var require_stream = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/stream.js"(exports, module2) {
    "use strict";
    var isStream = require_is_stream();
    var getStream = require_get_stream();
    var mergeStream = require_merge_stream();
    var handleInput = (spawned, input) => {
      if (input === void 0 || spawned.stdin === void 0) {
        return;
      }
      if (isStream(input)) {
        input.pipe(spawned.stdin);
      } else {
        spawned.stdin.end(input);
      }
    };
    var makeAllStream = (spawned, { all }) => {
      if (!all || !spawned.stdout && !spawned.stderr) {
        return;
      }
      const mixed = mergeStream();
      if (spawned.stdout) {
        mixed.add(spawned.stdout);
      }
      if (spawned.stderr) {
        mixed.add(spawned.stderr);
      }
      return mixed;
    };
    var getBufferedData = async (stream, streamPromise) => {
      if (!stream) {
        return;
      }
      stream.destroy();
      try {
        return await streamPromise;
      } catch (error) {
        return error.bufferedData;
      }
    };
    var getStreamPromise = (stream, { encoding, buffer, maxBuffer }) => {
      if (!stream || !buffer) {
        return;
      }
      if (encoding) {
        return getStream(stream, { encoding, maxBuffer });
      }
      return getStream.buffer(stream, { maxBuffer });
    };
    var getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
      const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });
      const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });
      const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
      try {
        return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
      } catch (error) {
        return Promise.all([
          { error, signal: error.signal, timedOut: error.timedOut },
          getBufferedData(stdout, stdoutPromise),
          getBufferedData(stderr, stderrPromise),
          getBufferedData(all, allPromise)
        ]);
      }
    };
    var validateInputSync = ({ input }) => {
      if (isStream(input)) {
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      }
    };
    module2.exports = {
      handleInput,
      makeAllStream,
      getSpawnedResult,
      validateInputSync
    };
  }
});
var require_promise = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/promise.js"(exports, module2) {
    "use strict";
    var nativePromisePrototype = (async () => {
    })().constructor.prototype;
    var descriptors = ["then", "catch", "finally"].map((property) => [
      property,
      Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
    ]);
    var mergePromise = (spawned, promise) => {
      for (const [property, descriptor] of descriptors) {
        const value = typeof promise === "function" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
        Reflect.defineProperty(spawned, property, { ...descriptor, value });
      }
      return spawned;
    };
    var getSpawnedPromise = (spawned) => {
      return new Promise((resolve, reject) => {
        spawned.on("exit", (exitCode, signal) => {
          resolve({ exitCode, signal });
        });
        spawned.on("error", (error) => {
          reject(error);
        });
        if (spawned.stdin) {
          spawned.stdin.on("error", (error) => {
            reject(error);
          });
        }
      });
    };
    module2.exports = {
      mergePromise,
      getSpawnedPromise
    };
  }
});
var require_command = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/lib/command.js"(exports, module2) {
    "use strict";
    var normalizeArgs = (file, args = []) => {
      if (!Array.isArray(args)) {
        return [file];
      }
      return [file, ...args];
    };
    var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
    var DOUBLE_QUOTES_REGEXP = /"/g;
    var escapeArg = (arg) => {
      if (typeof arg !== "string" || NO_ESCAPE_REGEXP.test(arg)) {
        return arg;
      }
      return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
    };
    var joinCommand = (file, args) => {
      return normalizeArgs(file, args).join(" ");
    };
    var getEscapedCommand = (file, args) => {
      return normalizeArgs(file, args).map((arg) => escapeArg(arg)).join(" ");
    };
    var SPACES_REGEXP = / +/g;
    var parseCommand = (command) => {
      const tokens = [];
      for (const token of command.trim().split(SPACES_REGEXP)) {
        const previousToken = tokens[tokens.length - 1];
        if (previousToken && previousToken.endsWith("\\")) {
          tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
        } else {
          tokens.push(token);
        }
      }
      return tokens;
    };
    module2.exports = {
      joinCommand,
      getEscapedCommand,
      parseCommand
    };
  }
});
var require_execa = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/execa@5.1.1/node_modules/execa/index.js"(exports, module2) {
    "use strict";
    var path2 = (0, import_chunk_2ESYSVXG.__require)("path");
    var childProcess = (0, import_chunk_2ESYSVXG.__require)("child_process");
    var crossSpawn = require_cross_spawn();
    var stripFinalNewline = require_strip_final_newline();
    var npmRunPath = require_npm_run_path();
    var onetime = require_onetime();
    var makeError = require_error();
    var normalizeStdio = require_stdio();
    var { spawnedKill, spawnedCancel, setupTimeout, validateTimeout, setExitHandler } = require_kill();
    var { handleInput, getSpawnedResult, makeAllStream, validateInputSync } = require_stream();
    var { mergePromise, getSpawnedPromise } = require_promise();
    var { joinCommand, parseCommand, getEscapedCommand } = require_command();
    var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
    var getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
      const env = extendEnv ? { ...process.env, ...envOption } : envOption;
      if (preferLocal) {
        return npmRunPath.env({ env, cwd: localDir, execPath });
      }
      return env;
    };
    var handleArguments = (file, args, options = {}) => {
      const parsed = crossSpawn._parse(file, args, options);
      file = parsed.command;
      args = parsed.args;
      options = parsed.options;
      options = {
        maxBuffer: DEFAULT_MAX_BUFFER,
        buffer: true,
        stripFinalNewline: true,
        extendEnv: true,
        preferLocal: false,
        localDir: options.cwd || process.cwd(),
        execPath: process.execPath,
        encoding: "utf8",
        reject: true,
        cleanup: true,
        all: false,
        windowsHide: true,
        ...options
      };
      options.env = getEnv(options);
      options.stdio = normalizeStdio(options);
      if (process.platform === "win32" && path2.basename(file, ".exe") === "cmd") {
        args.unshift("/q");
      }
      return { file, args, options, parsed };
    };
    var handleOutput = (options, value, error) => {
      if (typeof value !== "string" && !Buffer.isBuffer(value)) {
        return error === void 0 ? void 0 : "";
      }
      if (options.stripFinalNewline) {
        return stripFinalNewline(value);
      }
      return value;
    };
    var execa2 = (file, args, options) => {
      const parsed = handleArguments(file, args, options);
      const command = joinCommand(file, args);
      const escapedCommand = getEscapedCommand(file, args);
      validateTimeout(parsed.options);
      let spawned;
      try {
        spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        const dummySpawned = new childProcess.ChildProcess();
        const errorPromise = Promise.reject(makeError({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        }));
        return mergePromise(dummySpawned, errorPromise);
      }
      const spawnedPromise = getSpawnedPromise(spawned);
      const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
      const processDone = setExitHandler(spawned, parsed.options, timedPromise);
      const context = { isCanceled: false };
      spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
      spawned.cancel = spawnedCancel.bind(null, spawned, context);
      const handlePromise = async () => {
        const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
        const stdout = handleOutput(parsed.options, stdoutResult);
        const stderr = handleOutput(parsed.options, stderrResult);
        const all = handleOutput(parsed.options, allResult);
        if (error || exitCode !== 0 || signal !== null) {
          const returnedError = makeError({
            error,
            exitCode,
            signal,
            stdout,
            stderr,
            all,
            command,
            escapedCommand,
            parsed,
            timedOut,
            isCanceled: context.isCanceled,
            killed: spawned.killed
          });
          if (!parsed.options.reject) {
            return returnedError;
          }
          throw returnedError;
        }
        return {
          command,
          escapedCommand,
          exitCode: 0,
          stdout,
          stderr,
          all,
          failed: false,
          timedOut: false,
          isCanceled: false,
          killed: false
        };
      };
      const handlePromiseOnce = onetime(handlePromise);
      handleInput(spawned, parsed.options.input);
      spawned.all = makeAllStream(spawned, parsed.options);
      return mergePromise(spawned, handlePromiseOnce);
    };
    module2.exports = execa2;
    module2.exports.sync = (file, args, options) => {
      const parsed = handleArguments(file, args, options);
      const command = joinCommand(file, args);
      const escapedCommand = getEscapedCommand(file, args);
      validateInputSync(parsed.options);
      let result;
      try {
        result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);
      } catch (error) {
        throw makeError({
          error,
          stdout: "",
          stderr: "",
          all: "",
          command,
          escapedCommand,
          parsed,
          timedOut: false,
          isCanceled: false,
          killed: false
        });
      }
      const stdout = handleOutput(parsed.options, result.stdout, result.error);
      const stderr = handleOutput(parsed.options, result.stderr, result.error);
      if (result.error || result.status !== 0 || result.signal !== null) {
        const error = makeError({
          stdout,
          stderr,
          error: result.error,
          signal: result.signal,
          exitCode: result.status,
          command,
          escapedCommand,
          parsed,
          timedOut: result.error && result.error.code === "ETIMEDOUT",
          isCanceled: false,
          killed: result.signal !== null
        });
        if (!parsed.options.reject) {
          return error;
        }
        throw error;
      }
      return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    module2.exports.command = (command, options) => {
      const [file, ...args] = parseCommand(command);
      return execa2(file, args, options);
    };
    module2.exports.commandSync = (command, options) => {
      const [file, ...args] = parseCommand(command);
      return execa2.sync(file, args, options);
    };
    module2.exports.node = (scriptPath, args, options = {}) => {
      if (args && !Array.isArray(args) && typeof args === "object") {
        options = args;
        args = [];
      }
      const stdio = normalizeStdio.node(options);
      const defaultExecArgv = process.execArgv.filter((arg) => !arg.startsWith("--inspect"));
      const {
        nodePath = process.execPath,
        nodeOptions = defaultExecArgv
      } = options;
      return execa2(
        nodePath,
        [
          ...nodeOptions,
          scriptPath,
          ...Array.isArray(args) ? args : []
        ],
        {
          ...options,
          stdin: void 0,
          stdout: void 0,
          stderr: void 0,
          stdio,
          shell: false
        }
      );
    };
  }
});
var require_promisify = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/promisify.js"(exports, module2) {
    "use strict";
    module2.exports = (fn) => {
      return function() {
        const length = arguments.length;
        const args = new Array(length);
        for (let i = 0; i < length; i += 1) {
          args[i] = arguments[i];
        }
        return new Promise((resolve, reject) => {
          args.push((err, data) => {
            if (err) {
              reject(err);
            } else {
              resolve(data);
            }
          });
          fn.apply(null, args);
        });
      };
    };
  }
});
var require_fs = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/fs.js"(exports, module2) {
    "use strict";
    var fs2 = (0, import_chunk_2ESYSVXG.__require)("fs");
    var promisify = require_promisify();
    var isCallbackMethod = (key) => {
      return [
        typeof fs2[key] === "function",
        !key.match(/Sync$/),
        !key.match(/^[A-Z]/),
        !key.match(/^create/),
        !key.match(/^(un)?watch/)
      ].every(Boolean);
    };
    var adaptMethod = (name) => {
      const original = fs2[name];
      return promisify(original);
    };
    var adaptAllMethods = () => {
      const adapted = {};
      Object.keys(fs2).forEach((key) => {
        if (isCallbackMethod(key)) {
          if (key === "exists") {
            adapted.exists = () => {
              throw new Error("fs.exists() is deprecated");
            };
          } else {
            adapted[key] = adaptMethod(key);
          }
        } else {
          adapted[key] = fs2[key];
        }
      });
      return adapted;
    };
    module2.exports = adaptAllMethods();
  }
});
var require_validate = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/validate.js"(exports, module2) {
    "use strict";
    var prettyPrintTypes = (types) => {
      const addArticle = (str) => {
        const vowels = ["a", "e", "i", "o", "u"];
        if (vowels.indexOf(str[0]) !== -1) {
          return `an ${str}`;
        }
        return `a ${str}`;
      };
      return types.map(addArticle).join(" or ");
    };
    var isArrayOfNotation = (typeDefinition) => {
      return /array of /.test(typeDefinition);
    };
    var extractTypeFromArrayOfNotation = (typeDefinition) => {
      return typeDefinition.split(" of ")[1];
    };
    var isValidTypeDefinition = (typeStr) => {
      if (isArrayOfNotation(typeStr)) {
        return isValidTypeDefinition(extractTypeFromArrayOfNotation(typeStr));
      }
      return [
        "string",
        "number",
        "boolean",
        "array",
        "object",
        "buffer",
        "null",
        "undefined",
        "function"
      ].some((validType) => {
        return validType === typeStr;
      });
    };
    var detectType = (value) => {
      if (value === null) {
        return "null";
      }
      if (Array.isArray(value)) {
        return "array";
      }
      if (Buffer.isBuffer(value)) {
        return "buffer";
      }
      return typeof value;
    };
    var onlyUniqueValuesInArrayFilter = (value, index, self) => {
      return self.indexOf(value) === index;
    };
    var detectTypeDeep = (value) => {
      let type = detectType(value);
      let typesInArray;
      if (type === "array") {
        typesInArray = value.map((element) => {
          return detectType(element);
        }).filter(onlyUniqueValuesInArrayFilter);
        type += ` of ${typesInArray.join(", ")}`;
      }
      return type;
    };
    var validateArray = (argumentValue, typeToCheck) => {
      const allowedTypeInArray = extractTypeFromArrayOfNotation(typeToCheck);
      if (detectType(argumentValue) !== "array") {
        return false;
      }
      return argumentValue.every((element) => {
        return detectType(element) === allowedTypeInArray;
      });
    };
    var validateArgument = (methodName, argumentName, argumentValue, argumentMustBe) => {
      const isOneOfAllowedTypes = argumentMustBe.some((type) => {
        if (!isValidTypeDefinition(type)) {
          throw new Error(`Unknown type "${type}"`);
        }
        if (isArrayOfNotation(type)) {
          return validateArray(argumentValue, type);
        }
        return type === detectType(argumentValue);
      });
      if (!isOneOfAllowedTypes) {
        throw new Error(
          `Argument "${argumentName}" passed to ${methodName} must be ${prettyPrintTypes(
            argumentMustBe
          )}. Received ${detectTypeDeep(argumentValue)}`
        );
      }
    };
    var validateOptions = (methodName, optionsObjName, obj, allowedOptions) => {
      if (obj !== void 0) {
        validateArgument(methodName, optionsObjName, obj, ["object"]);
        Object.keys(obj).forEach((key) => {
          const argName = `${optionsObjName}.${key}`;
          if (allowedOptions[key] !== void 0) {
            validateArgument(methodName, argName, obj[key], allowedOptions[key]);
          } else {
            throw new Error(
              `Unknown argument "${argName}" passed to ${methodName}`
            );
          }
        });
      }
    };
    module2.exports = {
      argument: validateArgument,
      options: validateOptions
    };
  }
});
var require_mode2 = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/mode.js"(exports) {
    "use strict";
    exports.normalizeFileMode = (mode) => {
      let modeAsString;
      if (typeof mode === "number") {
        modeAsString = mode.toString(8);
      } else {
        modeAsString = mode;
      }
      return modeAsString.substring(modeAsString.length - 3);
    };
  }
});
var require_remove = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/remove.js"(exports) {
    "use strict";
    var fs2 = require_fs();
    var validate = require_validate();
    var validateInput = (methodName, path2) => {
      const methodSignature = `${methodName}([path])`;
      validate.argument(methodSignature, "path", path2, ["string", "undefined"]);
    };
    var removeSync = (path2) => {
      fs2.rmSync(path2, {
        recursive: true,
        force: true,
        maxRetries: 3
      });
    };
    var removeAsync = (path2) => {
      return fs2.rm(path2, {
        recursive: true,
        force: true,
        maxRetries: 3
      });
    };
    exports.validateInput = validateInput;
    exports.sync = removeSync;
    exports.async = removeAsync;
  }
});
var require_dir = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/dir.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs2 = require_fs();
    var modeUtil = require_mode2();
    var validate = require_validate();
    var remove = require_remove();
    var validateInput = (methodName, path2, criteria) => {
      const methodSignature = `${methodName}(path, [criteria])`;
      validate.argument(methodSignature, "path", path2, ["string"]);
      validate.options(methodSignature, "criteria", criteria, {
        empty: ["boolean"],
        mode: ["string", "number"]
      });
    };
    var getCriteriaDefaults = (passedCriteria) => {
      const criteria = passedCriteria || {};
      if (typeof criteria.empty !== "boolean") {
        criteria.empty = false;
      }
      if (criteria.mode !== void 0) {
        criteria.mode = modeUtil.normalizeFileMode(criteria.mode);
      }
      return criteria;
    };
    var generatePathOccupiedByNotDirectoryError = (path2) => {
      return new Error(
        `Path ${path2} exists but is not a directory. Halting jetpack.dir() call for safety reasons.`
      );
    };
    var checkWhatAlreadyOccupiesPathSync = (path2) => {
      let stat;
      try {
        stat = fs2.statSync(path2);
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
      if (stat && !stat.isDirectory()) {
        throw generatePathOccupiedByNotDirectoryError(path2);
      }
      return stat;
    };
    var createBrandNewDirectorySync = (path2, opts) => {
      const options = opts || {};
      try {
        fs2.mkdirSync(path2, options.mode);
      } catch (err) {
        if (err.code === "ENOENT") {
          createBrandNewDirectorySync(pathUtil.dirname(path2), options);
          fs2.mkdirSync(path2, options.mode);
        } else if (err.code === "EEXIST") {
        } else {
          throw err;
        }
      }
    };
    var checkExistingDirectoryFulfillsCriteriaSync = (path2, stat, criteria) => {
      const checkMode = () => {
        const mode = modeUtil.normalizeFileMode(stat.mode);
        if (criteria.mode !== void 0 && criteria.mode !== mode) {
          fs2.chmodSync(path2, criteria.mode);
        }
      };
      const checkEmptiness = () => {
        if (criteria.empty) {
          const list = fs2.readdirSync(path2);
          list.forEach((filename) => {
            remove.sync(pathUtil.resolve(path2, filename));
          });
        }
      };
      checkMode();
      checkEmptiness();
    };
    var dirSync = (path2, passedCriteria) => {
      const criteria = getCriteriaDefaults(passedCriteria);
      const stat = checkWhatAlreadyOccupiesPathSync(path2);
      if (stat) {
        checkExistingDirectoryFulfillsCriteriaSync(path2, stat, criteria);
      } else {
        createBrandNewDirectorySync(path2, criteria);
      }
    };
    var checkWhatAlreadyOccupiesPathAsync = (path2) => {
      return new Promise((resolve, reject) => {
        fs2.stat(path2).then((stat) => {
          if (stat.isDirectory()) {
            resolve(stat);
          } else {
            reject(generatePathOccupiedByNotDirectoryError(path2));
          }
        }).catch((err) => {
          if (err.code === "ENOENT") {
            resolve(void 0);
          } else {
            reject(err);
          }
        });
      });
    };
    var emptyAsync = (path2) => {
      return new Promise((resolve, reject) => {
        fs2.readdir(path2).then((list) => {
          const doOne = (index) => {
            if (index === list.length) {
              resolve();
            } else {
              const subPath = pathUtil.resolve(path2, list[index]);
              remove.async(subPath).then(() => {
                doOne(index + 1);
              });
            }
          };
          doOne(0);
        }).catch(reject);
      });
    };
    var checkExistingDirectoryFulfillsCriteriaAsync = (path2, stat, criteria) => {
      return new Promise((resolve, reject) => {
        const checkMode = () => {
          const mode = modeUtil.normalizeFileMode(stat.mode);
          if (criteria.mode !== void 0 && criteria.mode !== mode) {
            return fs2.chmod(path2, criteria.mode);
          }
          return Promise.resolve();
        };
        const checkEmptiness = () => {
          if (criteria.empty) {
            return emptyAsync(path2);
          }
          return Promise.resolve();
        };
        checkMode().then(checkEmptiness).then(resolve, reject);
      });
    };
    var createBrandNewDirectoryAsync = (path2, opts) => {
      const options = opts || {};
      return new Promise((resolve, reject) => {
        fs2.mkdir(path2, options.mode).then(resolve).catch((err) => {
          if (err.code === "ENOENT") {
            createBrandNewDirectoryAsync(pathUtil.dirname(path2), options).then(() => {
              return fs2.mkdir(path2, options.mode);
            }).then(resolve).catch((err2) => {
              if (err2.code === "EEXIST") {
                resolve();
              } else {
                reject(err2);
              }
            });
          } else if (err.code === "EEXIST") {
            resolve();
          } else {
            reject(err);
          }
        });
      });
    };
    var dirAsync = (path2, passedCriteria) => {
      return new Promise((resolve, reject) => {
        const criteria = getCriteriaDefaults(passedCriteria);
        checkWhatAlreadyOccupiesPathAsync(path2).then((stat) => {
          if (stat !== void 0) {
            return checkExistingDirectoryFulfillsCriteriaAsync(
              path2,
              stat,
              criteria
            );
          }
          return createBrandNewDirectoryAsync(path2, criteria);
        }).then(resolve, reject);
      });
    };
    exports.validateInput = validateInput;
    exports.sync = dirSync;
    exports.createSync = createBrandNewDirectorySync;
    exports.async = dirAsync;
    exports.createAsync = createBrandNewDirectoryAsync;
  }
});
var require_write = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/write.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs2 = require_fs();
    var validate = require_validate();
    var dir = require_dir();
    var validateInput = (methodName, path2, data, options) => {
      const methodSignature = `${methodName}(path, data, [options])`;
      validate.argument(methodSignature, "path", path2, ["string"]);
      validate.argument(methodSignature, "data", data, [
        "string",
        "buffer",
        "object",
        "array"
      ]);
      validate.options(methodSignature, "options", options, {
        mode: ["string", "number"],
        atomic: ["boolean"],
        jsonIndent: ["number"]
      });
    };
    var newExt = ".__new__";
    var serializeToJsonMaybe = (data, jsonIndent) => {
      let indent = jsonIndent;
      if (typeof indent !== "number") {
        indent = 2;
      }
      if (typeof data === "object" && !Buffer.isBuffer(data) && data !== null) {
        return JSON.stringify(data, null, indent);
      }
      return data;
    };
    var writeFileSync = (path2, data, options) => {
      try {
        fs2.writeFileSync(path2, data, options);
      } catch (err) {
        if (err.code === "ENOENT") {
          dir.createSync(pathUtil.dirname(path2));
          fs2.writeFileSync(path2, data, options);
        } else {
          throw err;
        }
      }
    };
    var writeAtomicSync = (path2, data, options) => {
      writeFileSync(path2 + newExt, data, options);
      fs2.renameSync(path2 + newExt, path2);
    };
    var writeSync = (path2, data, options) => {
      const opts = options || {};
      const processedData = serializeToJsonMaybe(data, opts.jsonIndent);
      let writeStrategy = writeFileSync;
      if (opts.atomic) {
        writeStrategy = writeAtomicSync;
      }
      writeStrategy(path2, processedData, { mode: opts.mode });
    };
    var writeFileAsync = (path2, data, options) => {
      return new Promise((resolve, reject) => {
        fs2.writeFile(path2, data, options).then(resolve).catch((err) => {
          if (err.code === "ENOENT") {
            dir.createAsync(pathUtil.dirname(path2)).then(() => {
              return fs2.writeFile(path2, data, options);
            }).then(resolve, reject);
          } else {
            reject(err);
          }
        });
      });
    };
    var writeAtomicAsync = (path2, data, options) => {
      return new Promise((resolve, reject) => {
        writeFileAsync(path2 + newExt, data, options).then(() => {
          return fs2.rename(path2 + newExt, path2);
        }).then(resolve, reject);
      });
    };
    var writeAsync = (path2, data, options) => {
      const opts = options || {};
      const processedData = serializeToJsonMaybe(data, opts.jsonIndent);
      let writeStrategy = writeFileAsync;
      if (opts.atomic) {
        writeStrategy = writeAtomicAsync;
      }
      return writeStrategy(path2, processedData, { mode: opts.mode });
    };
    exports.validateInput = validateInput;
    exports.sync = writeSync;
    exports.async = writeAsync;
  }
});
var require_append = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/append.js"(exports) {
    "use strict";
    var fs2 = require_fs();
    var write = require_write();
    var validate = require_validate();
    var validateInput = (methodName, path2, data, options) => {
      const methodSignature = `${methodName}(path, data, [options])`;
      validate.argument(methodSignature, "path", path2, ["string"]);
      validate.argument(methodSignature, "data", data, ["string", "buffer"]);
      validate.options(methodSignature, "options", options, {
        mode: ["string", "number"]
      });
    };
    var appendSync = (path2, data, options) => {
      try {
        fs2.appendFileSync(path2, data, options);
      } catch (err) {
        if (err.code === "ENOENT") {
          write.sync(path2, data, options);
        } else {
          throw err;
        }
      }
    };
    var appendAsync = (path2, data, options) => {
      return new Promise((resolve, reject) => {
        fs2.appendFile(path2, data, options).then(resolve).catch((err) => {
          if (err.code === "ENOENT") {
            write.async(path2, data, options).then(resolve, reject);
          } else {
            reject(err);
          }
        });
      });
    };
    exports.validateInput = validateInput;
    exports.sync = appendSync;
    exports.async = appendAsync;
  }
});
var require_file = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/file.js"(exports) {
    "use strict";
    var fs2 = require_fs();
    var modeUtil = require_mode2();
    var validate = require_validate();
    var write = require_write();
    var validateInput = (methodName, path2, criteria) => {
      const methodSignature = `${methodName}(path, [criteria])`;
      validate.argument(methodSignature, "path", path2, ["string"]);
      validate.options(methodSignature, "criteria", criteria, {
        content: ["string", "buffer", "object", "array"],
        jsonIndent: ["number"],
        mode: ["string", "number"]
      });
    };
    var getCriteriaDefaults = (passedCriteria) => {
      const criteria = passedCriteria || {};
      if (criteria.mode !== void 0) {
        criteria.mode = modeUtil.normalizeFileMode(criteria.mode);
      }
      return criteria;
    };
    var generatePathOccupiedByNotFileError = (path2) => {
      return new Error(
        `Path ${path2} exists but is not a file. Halting jetpack.file() call for safety reasons.`
      );
    };
    var checkWhatAlreadyOccupiesPathSync = (path2) => {
      let stat;
      try {
        stat = fs2.statSync(path2);
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
      if (stat && !stat.isFile()) {
        throw generatePathOccupiedByNotFileError(path2);
      }
      return stat;
    };
    var checkExistingFileFulfillsCriteriaSync = (path2, stat, criteria) => {
      const mode = modeUtil.normalizeFileMode(stat.mode);
      const checkContent = () => {
        if (criteria.content !== void 0) {
          write.sync(path2, criteria.content, {
            mode,
            jsonIndent: criteria.jsonIndent
          });
          return true;
        }
        return false;
      };
      const checkMode = () => {
        if (criteria.mode !== void 0 && criteria.mode !== mode) {
          fs2.chmodSync(path2, criteria.mode);
        }
      };
      const contentReplaced = checkContent();
      if (!contentReplaced) {
        checkMode();
      }
    };
    var createBrandNewFileSync = (path2, criteria) => {
      let content = "";
      if (criteria.content !== void 0) {
        content = criteria.content;
      }
      write.sync(path2, content, {
        mode: criteria.mode,
        jsonIndent: criteria.jsonIndent
      });
    };
    var fileSync = (path2, passedCriteria) => {
      const criteria = getCriteriaDefaults(passedCriteria);
      const stat = checkWhatAlreadyOccupiesPathSync(path2);
      if (stat !== void 0) {
        checkExistingFileFulfillsCriteriaSync(path2, stat, criteria);
      } else {
        createBrandNewFileSync(path2, criteria);
      }
    };
    var checkWhatAlreadyOccupiesPathAsync = (path2) => {
      return new Promise((resolve, reject) => {
        fs2.stat(path2).then((stat) => {
          if (stat.isFile()) {
            resolve(stat);
          } else {
            reject(generatePathOccupiedByNotFileError(path2));
          }
        }).catch((err) => {
          if (err.code === "ENOENT") {
            resolve(void 0);
          } else {
            reject(err);
          }
        });
      });
    };
    var checkExistingFileFulfillsCriteriaAsync = (path2, stat, criteria) => {
      const mode = modeUtil.normalizeFileMode(stat.mode);
      const checkContent = () => {
        return new Promise((resolve, reject) => {
          if (criteria.content !== void 0) {
            write.async(path2, criteria.content, {
              mode,
              jsonIndent: criteria.jsonIndent
            }).then(() => {
              resolve(true);
            }).catch(reject);
          } else {
            resolve(false);
          }
        });
      };
      const checkMode = () => {
        if (criteria.mode !== void 0 && criteria.mode !== mode) {
          return fs2.chmod(path2, criteria.mode);
        }
        return void 0;
      };
      return checkContent().then((contentReplaced) => {
        if (!contentReplaced) {
          return checkMode();
        }
        return void 0;
      });
    };
    var createBrandNewFileAsync = (path2, criteria) => {
      let content = "";
      if (criteria.content !== void 0) {
        content = criteria.content;
      }
      return write.async(path2, content, {
        mode: criteria.mode,
        jsonIndent: criteria.jsonIndent
      });
    };
    var fileAsync = (path2, passedCriteria) => {
      return new Promise((resolve, reject) => {
        const criteria = getCriteriaDefaults(passedCriteria);
        checkWhatAlreadyOccupiesPathAsync(path2).then((stat) => {
          if (stat !== void 0) {
            return checkExistingFileFulfillsCriteriaAsync(path2, stat, criteria);
          }
          return createBrandNewFileAsync(path2, criteria);
        }).then(resolve, reject);
      });
    };
    exports.validateInput = validateInput;
    exports.sync = fileSync;
    exports.async = fileAsync;
  }
});
var require_inspect = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/inspect.js"(exports) {
    "use strict";
    var crypto = (0, import_chunk_2ESYSVXG.__require)("crypto");
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs2 = require_fs();
    var validate = require_validate();
    var supportedChecksumAlgorithms = ["md5", "sha1", "sha256", "sha512"];
    var symlinkOptions = ["report", "follow"];
    var validateInput = (methodName, path2, options) => {
      const methodSignature = `${methodName}(path, [options])`;
      validate.argument(methodSignature, "path", path2, ["string"]);
      validate.options(methodSignature, "options", options, {
        checksum: ["string"],
        mode: ["boolean"],
        times: ["boolean"],
        absolutePath: ["boolean"],
        symlinks: ["string"]
      });
      if (options && options.checksum !== void 0 && supportedChecksumAlgorithms.indexOf(options.checksum) === -1) {
        throw new Error(
          `Argument "options.checksum" passed to ${methodSignature} must have one of values: ${supportedChecksumAlgorithms.join(
            ", "
          )}`
        );
      }
      if (options && options.symlinks !== void 0 && symlinkOptions.indexOf(options.symlinks) === -1) {
        throw new Error(
          `Argument "options.symlinks" passed to ${methodSignature} must have one of values: ${symlinkOptions.join(
            ", "
          )}`
        );
      }
    };
    var createInspectObj = (path2, options, stat) => {
      const obj = {};
      obj.name = pathUtil.basename(path2);
      if (stat.isFile()) {
        obj.type = "file";
        obj.size = stat.size;
      } else if (stat.isDirectory()) {
        obj.type = "dir";
      } else if (stat.isSymbolicLink()) {
        obj.type = "symlink";
      } else {
        obj.type = "other";
      }
      if (options.mode) {
        obj.mode = stat.mode;
      }
      if (options.times) {
        obj.accessTime = stat.atime;
        obj.modifyTime = stat.mtime;
        obj.changeTime = stat.ctime;
        obj.birthTime = stat.birthtime;
      }
      if (options.absolutePath) {
        obj.absolutePath = path2;
      }
      return obj;
    };
    var fileChecksum = (path2, algo) => {
      const hash = crypto.createHash(algo);
      const data = fs2.readFileSync(path2);
      hash.update(data);
      return hash.digest("hex");
    };
    var addExtraFieldsSync = (path2, inspectObj, options) => {
      if (inspectObj.type === "file" && options.checksum) {
        inspectObj[options.checksum] = fileChecksum(path2, options.checksum);
      } else if (inspectObj.type === "symlink") {
        inspectObj.pointsAt = fs2.readlinkSync(path2);
      }
    };
    var inspectSync = (path2, options) => {
      let statOperation = fs2.lstatSync;
      let stat;
      const opts = options || {};
      if (opts.symlinks === "follow") {
        statOperation = fs2.statSync;
      }
      try {
        stat = statOperation(path2);
      } catch (err) {
        if (err.code === "ENOENT") {
          return void 0;
        }
        throw err;
      }
      const inspectObj = createInspectObj(path2, opts, stat);
      addExtraFieldsSync(path2, inspectObj, opts);
      return inspectObj;
    };
    var fileChecksumAsync = (path2, algo) => {
      return new Promise((resolve, reject) => {
        const hash = crypto.createHash(algo);
        const s = fs2.createReadStream(path2);
        s.on("data", (data) => {
          hash.update(data);
        });
        s.on("end", () => {
          resolve(hash.digest("hex"));
        });
        s.on("error", reject);
      });
    };
    var addExtraFieldsAsync = (path2, inspectObj, options) => {
      if (inspectObj.type === "file" && options.checksum) {
        return fileChecksumAsync(path2, options.checksum).then((checksum) => {
          inspectObj[options.checksum] = checksum;
          return inspectObj;
        });
      } else if (inspectObj.type === "symlink") {
        return fs2.readlink(path2).then((linkPath) => {
          inspectObj.pointsAt = linkPath;
          return inspectObj;
        });
      }
      return Promise.resolve(inspectObj);
    };
    var inspectAsync = (path2, options) => {
      return new Promise((resolve, reject) => {
        let statOperation = fs2.lstat;
        const opts = options || {};
        if (opts.symlinks === "follow") {
          statOperation = fs2.stat;
        }
        statOperation(path2).then((stat) => {
          const inspectObj = createInspectObj(path2, opts, stat);
          addExtraFieldsAsync(path2, inspectObj, opts).then(resolve, reject);
        }).catch((err) => {
          if (err.code === "ENOENT") {
            resolve(void 0);
          } else {
            reject(err);
          }
        });
      });
    };
    exports.supportedChecksumAlgorithms = supportedChecksumAlgorithms;
    exports.symlinkOptions = symlinkOptions;
    exports.validateInput = validateInput;
    exports.sync = inspectSync;
    exports.async = inspectAsync;
  }
});
var require_list = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/list.js"(exports) {
    "use strict";
    var fs2 = require_fs();
    var validate = require_validate();
    var validateInput = (methodName, path2) => {
      const methodSignature = `${methodName}(path)`;
      validate.argument(methodSignature, "path", path2, ["string", "undefined"]);
    };
    var listSync = (path2) => {
      try {
        return fs2.readdirSync(path2);
      } catch (err) {
        if (err.code === "ENOENT") {
          return void 0;
        }
        throw err;
      }
    };
    var listAsync = (path2) => {
      return new Promise((resolve, reject) => {
        fs2.readdir(path2).then((list) => {
          resolve(list);
        }).catch((err) => {
          if (err.code === "ENOENT") {
            resolve(void 0);
          } else {
            reject(err);
          }
        });
      });
    };
    exports.validateInput = validateInput;
    exports.sync = listSync;
    exports.async = listAsync;
  }
});
var require_tree_walker = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/tree_walker.js"(exports) {
    "use strict";
    var fs2 = (0, import_chunk_2ESYSVXG.__require)("fs");
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var inspect = require_inspect();
    var list = require_list();
    var fileType = (dirent) => {
      if (dirent.isDirectory()) {
        return "dir";
      }
      if (dirent.isFile()) {
        return "file";
      }
      if (dirent.isSymbolicLink()) {
        return "symlink";
      }
      return "other";
    };
    var initialWalkSync = (path2, options, callback) => {
      if (options.maxLevelsDeep === void 0) {
        options.maxLevelsDeep = Infinity;
      }
      const performInspectOnEachNode = options.inspectOptions !== void 0;
      if (options.symlinks) {
        if (options.inspectOptions === void 0) {
          options.inspectOptions = { symlinks: options.symlinks };
        } else {
          options.inspectOptions.symlinks = options.symlinks;
        }
      }
      const walkSync = (path3, currentLevel) => {
        fs2.readdirSync(path3, { withFileTypes: true }).forEach((direntItem) => {
          const withFileTypesNotSupported = typeof direntItem === "string";
          let fileItemPath;
          if (withFileTypesNotSupported) {
            fileItemPath = pathUtil.join(path3, direntItem);
          } else {
            fileItemPath = pathUtil.join(path3, direntItem.name);
          }
          let fileItem;
          if (performInspectOnEachNode) {
            fileItem = inspect.sync(fileItemPath, options.inspectOptions);
          } else if (withFileTypesNotSupported) {
            const inspectObject = inspect.sync(
              fileItemPath,
              options.inspectOptions
            );
            fileItem = { name: inspectObject.name, type: inspectObject.type };
          } else {
            const type = fileType(direntItem);
            if (type === "symlink" && options.symlinks === "follow") {
              const symlinkPointsTo = fs2.statSync(fileItemPath);
              fileItem = { name: direntItem.name, type: fileType(symlinkPointsTo) };
            } else {
              fileItem = { name: direntItem.name, type };
            }
          }
          if (fileItem !== void 0) {
            callback(fileItemPath, fileItem);
            if (fileItem.type === "dir" && currentLevel < options.maxLevelsDeep) {
              walkSync(fileItemPath, currentLevel + 1);
            }
          }
        });
      };
      const item = inspect.sync(path2, options.inspectOptions);
      if (item) {
        if (performInspectOnEachNode) {
          callback(path2, item);
        } else {
          callback(path2, { name: item.name, type: item.type });
        }
        if (item.type === "dir") {
          walkSync(path2, 1);
        }
      } else {
        callback(path2, void 0);
      }
    };
    var maxConcurrentOperations = 5;
    var initialWalkAsync = (path2, options, callback, doneCallback) => {
      if (options.maxLevelsDeep === void 0) {
        options.maxLevelsDeep = Infinity;
      }
      const performInspectOnEachNode = options.inspectOptions !== void 0;
      if (options.symlinks) {
        if (options.inspectOptions === void 0) {
          options.inspectOptions = { symlinks: options.symlinks };
        } else {
          options.inspectOptions.symlinks = options.symlinks;
        }
      }
      const concurrentOperationsQueue = [];
      let nowDoingConcurrentOperations = 0;
      const checkConcurrentOperations = () => {
        if (concurrentOperationsQueue.length === 0 && nowDoingConcurrentOperations === 0) {
          doneCallback();
        } else if (concurrentOperationsQueue.length > 0 && nowDoingConcurrentOperations < maxConcurrentOperations) {
          const operation = concurrentOperationsQueue.pop();
          nowDoingConcurrentOperations += 1;
          operation();
        }
      };
      const whenConcurrencySlotAvailable = (operation) => {
        concurrentOperationsQueue.push(operation);
        checkConcurrentOperations();
      };
      const concurrentOperationDone = () => {
        nowDoingConcurrentOperations -= 1;
        checkConcurrentOperations();
      };
      const walkAsync = (path3, currentLevel) => {
        const goDeeperIfDir = (fileItemPath, fileItem) => {
          if (fileItem.type === "dir" && currentLevel < options.maxLevelsDeep) {
            walkAsync(fileItemPath, currentLevel + 1);
          }
        };
        whenConcurrencySlotAvailable(() => {
          fs2.readdir(path3, { withFileTypes: true }, (err, files) => {
            if (err) {
              doneCallback(err);
            } else {
              files.forEach((direntItem) => {
                const withFileTypesNotSupported = typeof direntItem === "string";
                let fileItemPath;
                if (withFileTypesNotSupported) {
                  fileItemPath = pathUtil.join(path3, direntItem);
                } else {
                  fileItemPath = pathUtil.join(path3, direntItem.name);
                }
                if (performInspectOnEachNode || withFileTypesNotSupported) {
                  whenConcurrencySlotAvailable(() => {
                    inspect.async(fileItemPath, options.inspectOptions).then((fileItem) => {
                      if (fileItem !== void 0) {
                        if (performInspectOnEachNode) {
                          callback(fileItemPath, fileItem);
                        } else {
                          callback(fileItemPath, {
                            name: fileItem.name,
                            type: fileItem.type
                          });
                        }
                        goDeeperIfDir(fileItemPath, fileItem);
                      }
                      concurrentOperationDone();
                    }).catch((err2) => {
                      doneCallback(err2);
                    });
                  });
                } else {
                  const type = fileType(direntItem);
                  if (type === "symlink" && options.symlinks === "follow") {
                    whenConcurrencySlotAvailable(() => {
                      fs2.stat(fileItemPath, (err2, symlinkPointsTo) => {
                        if (err2) {
                          doneCallback(err2);
                        } else {
                          const fileItem = {
                            name: direntItem.name,
                            type: fileType(symlinkPointsTo)
                          };
                          callback(fileItemPath, fileItem);
                          goDeeperIfDir(fileItemPath, fileItem);
                          concurrentOperationDone();
                        }
                      });
                    });
                  } else {
                    const fileItem = { name: direntItem.name, type };
                    callback(fileItemPath, fileItem);
                    goDeeperIfDir(fileItemPath, fileItem);
                  }
                }
              });
              concurrentOperationDone();
            }
          });
        });
      };
      inspect.async(path2, options.inspectOptions).then((item) => {
        if (item) {
          if (performInspectOnEachNode) {
            callback(path2, item);
          } else {
            callback(path2, { name: item.name, type: item.type });
          }
          if (item.type === "dir") {
            walkAsync(path2, 1);
          } else {
            doneCallback();
          }
        } else {
          callback(path2, void 0);
          doneCallback();
        }
      }).catch((err) => {
        doneCallback(err);
      });
    };
    exports.sync = initialWalkSync;
    exports.async = initialWalkAsync;
  }
});
var require_path = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/minimatch@5.1.0/node_modules/minimatch/lib/path.js"(exports, module2) {
    "use strict";
    var isWindows = typeof process === "object" && process && process.platform === "win32";
    module2.exports = isWindows ? { sep: "\\" } : { sep: "/" };
  }
});
var require_balanced_match = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});
var require_brace_expansion = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module2) {
    "use strict";
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m) return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});
var require_minimatch = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/minimatch@5.1.0/node_modules/minimatch/minimatch.js"(exports, module2) {
    "use strict";
    var minimatch = module2.exports = (p, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    module2.exports = minimatch;
    var path2 = require_path();
    minimatch.sep = path2.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR;
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      const orig = minimatch;
      const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m.defaults = (options) => orig.defaults(ext(def, options));
      m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m;
    };
    minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options) options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug) this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate) return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset) this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false) return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".") return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl) return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit) return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "") return "";
        let re = "";
        let hasMagic = !!options.nocase;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        const patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1) c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext) clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
              hasMagic = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const openParensBefore = nlBefore.split("(").length - 1;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false) return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate) re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) return false;
        if (this.empty) return f === "";
        if (f === "/" && partial) return true;
        const options = this.options;
        if (path2.sep !== "/") {
          f = f.split(path2.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename) break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate) return true;
            return !this.negate;
          }
        }
        if (options.flipNegate) return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
    minimatch.Minimatch = Minimatch;
  }
});
var require_matcher = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/matcher.js"(exports) {
    "use strict";
    var Minimatch = require_minimatch().Minimatch;
    var convertPatternToAbsolutePath = (basePath, pattern) => {
      const hasSlash = pattern.indexOf("/") !== -1;
      const isAbsolute = /^!?\//.test(pattern);
      const isNegated = /^!/.test(pattern);
      let separator;
      if (!isAbsolute && hasSlash) {
        const patternWithoutFirstCharacters = pattern.replace(/^!/, "").replace(/^\.\//, "");
        if (/\/$/.test(basePath)) {
          separator = "";
        } else {
          separator = "/";
        }
        if (isNegated) {
          return `!${basePath}${separator}${patternWithoutFirstCharacters}`;
        }
        return `${basePath}${separator}${patternWithoutFirstCharacters}`;
      }
      return pattern;
    };
    exports.create = (basePath, patterns, ignoreCase) => {
      let normalizedPatterns;
      if (typeof patterns === "string") {
        normalizedPatterns = [patterns];
      } else {
        normalizedPatterns = patterns;
      }
      const matchers = normalizedPatterns.map((pattern) => {
        return convertPatternToAbsolutePath(basePath, pattern);
      }).map((pattern) => {
        return new Minimatch(pattern, {
          matchBase: true,
          nocomment: true,
          nocase: ignoreCase || false,
          dot: true,
          windowsPathsNoEscape: true
        });
      });
      const performMatch = (absolutePath) => {
        let mode = "matching";
        let weHaveMatch = false;
        let currentMatcher;
        let i;
        for (i = 0; i < matchers.length; i += 1) {
          currentMatcher = matchers[i];
          if (currentMatcher.negate) {
            mode = "negation";
            if (i === 0) {
              weHaveMatch = true;
            }
          }
          if (mode === "negation" && weHaveMatch && !currentMatcher.match(absolutePath)) {
            return false;
          }
          if (mode === "matching" && !weHaveMatch) {
            weHaveMatch = currentMatcher.match(absolutePath);
          }
        }
        return weHaveMatch;
      };
      return performMatch;
    };
  }
});
var require_find = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/find.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var treeWalker = require_tree_walker();
    var inspect = require_inspect();
    var matcher = require_matcher();
    var validate = require_validate();
    var validateInput = (methodName, path2, options) => {
      const methodSignature = `${methodName}([path], options)`;
      validate.argument(methodSignature, "path", path2, ["string"]);
      validate.options(methodSignature, "options", options, {
        matching: ["string", "array of string"],
        filter: ["function"],
        files: ["boolean"],
        directories: ["boolean"],
        recursive: ["boolean"],
        ignoreCase: ["boolean"]
      });
    };
    var normalizeOptions = (options) => {
      const opts = options || {};
      if (opts.matching === void 0) {
        opts.matching = "*";
      }
      if (opts.files === void 0) {
        opts.files = true;
      }
      if (opts.ignoreCase === void 0) {
        opts.ignoreCase = false;
      }
      if (opts.directories === void 0) {
        opts.directories = false;
      }
      if (opts.recursive === void 0) {
        opts.recursive = true;
      }
      return opts;
    };
    var processFoundPaths = (foundPaths, cwd) => {
      return foundPaths.map((path2) => {
        return pathUtil.relative(cwd, path2);
      });
    };
    var generatePathDoesntExistError = (path2) => {
      const err = new Error(`Path you want to find stuff in doesn't exist ${path2}`);
      err.code = "ENOENT";
      return err;
    };
    var generatePathNotDirectoryError = (path2) => {
      const err = new Error(
        `Path you want to find stuff in must be a directory ${path2}`
      );
      err.code = "ENOTDIR";
      return err;
    };
    var findSync = (path2, options) => {
      const foundAbsolutePaths = [];
      const matchesAnyOfGlobs = matcher.create(
        path2,
        options.matching,
        options.ignoreCase
      );
      let maxLevelsDeep = Infinity;
      if (options.recursive === false) {
        maxLevelsDeep = 1;
      }
      treeWalker.sync(
        path2,
        {
          maxLevelsDeep,
          symlinks: "follow",
          inspectOptions: { times: true, absolutePath: true }
        },
        (itemPath, item) => {
          if (item && itemPath !== path2 && matchesAnyOfGlobs(itemPath)) {
            const weHaveMatch = item.type === "file" && options.files === true || item.type === "dir" && options.directories === true;
            if (weHaveMatch) {
              if (options.filter) {
                const passedThroughFilter = options.filter(item);
                if (passedThroughFilter) {
                  foundAbsolutePaths.push(itemPath);
                }
              } else {
                foundAbsolutePaths.push(itemPath);
              }
            }
          }
        }
      );
      foundAbsolutePaths.sort();
      return processFoundPaths(foundAbsolutePaths, options.cwd);
    };
    var findSyncInit = (path2, options) => {
      const entryPointInspect = inspect.sync(path2, { symlinks: "follow" });
      if (entryPointInspect === void 0) {
        throw generatePathDoesntExistError(path2);
      } else if (entryPointInspect.type !== "dir") {
        throw generatePathNotDirectoryError(path2);
      }
      return findSync(path2, normalizeOptions(options));
    };
    var findAsync = (path2, options) => {
      return new Promise((resolve, reject) => {
        const foundAbsolutePaths = [];
        const matchesAnyOfGlobs = matcher.create(
          path2,
          options.matching,
          options.ignoreCase
        );
        let maxLevelsDeep = Infinity;
        if (options.recursive === false) {
          maxLevelsDeep = 1;
        }
        let waitingForFiltersToFinish = 0;
        let treeWalkerDone = false;
        const maybeDone = () => {
          if (treeWalkerDone && waitingForFiltersToFinish === 0) {
            foundAbsolutePaths.sort();
            resolve(processFoundPaths(foundAbsolutePaths, options.cwd));
          }
        };
        treeWalker.async(
          path2,
          {
            maxLevelsDeep,
            symlinks: "follow",
            inspectOptions: { times: true, absolutePath: true }
          },
          (itemPath, item) => {
            if (item && itemPath !== path2 && matchesAnyOfGlobs(itemPath)) {
              const weHaveMatch = item.type === "file" && options.files === true || item.type === "dir" && options.directories === true;
              if (weHaveMatch) {
                if (options.filter) {
                  const passedThroughFilter = options.filter(item);
                  const isPromise = typeof passedThroughFilter.then === "function";
                  if (isPromise) {
                    waitingForFiltersToFinish += 1;
                    passedThroughFilter.then((passedThroughFilterResult) => {
                      if (passedThroughFilterResult) {
                        foundAbsolutePaths.push(itemPath);
                      }
                      waitingForFiltersToFinish -= 1;
                      maybeDone();
                    }).catch((err) => {
                      reject(err);
                    });
                  } else if (passedThroughFilter) {
                    foundAbsolutePaths.push(itemPath);
                  }
                } else {
                  foundAbsolutePaths.push(itemPath);
                }
              }
            }
          },
          (err) => {
            if (err) {
              reject(err);
            } else {
              treeWalkerDone = true;
              maybeDone();
            }
          }
        );
      });
    };
    var findAsyncInit = (path2, options) => {
      return inspect.async(path2, { symlinks: "follow" }).then((entryPointInspect) => {
        if (entryPointInspect === void 0) {
          throw generatePathDoesntExistError(path2);
        } else if (entryPointInspect.type !== "dir") {
          throw generatePathNotDirectoryError(path2);
        }
        return findAsync(path2, normalizeOptions(options));
      });
    };
    exports.validateInput = validateInput;
    exports.sync = findSyncInit;
    exports.async = findAsyncInit;
  }
});
var require_inspect_tree = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/inspect_tree.js"(exports) {
    "use strict";
    var crypto = (0, import_chunk_2ESYSVXG.__require)("crypto");
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var inspect = require_inspect();
    var list = require_list();
    var validate = require_validate();
    var treeWalker = require_tree_walker();
    var validateInput = (methodName, path2, options) => {
      const methodSignature = `${methodName}(path, [options])`;
      validate.argument(methodSignature, "path", path2, ["string"]);
      validate.options(methodSignature, "options", options, {
        checksum: ["string"],
        relativePath: ["boolean"],
        times: ["boolean"],
        symlinks: ["string"]
      });
      if (options && options.checksum !== void 0 && inspect.supportedChecksumAlgorithms.indexOf(options.checksum) === -1) {
        throw new Error(
          `Argument "options.checksum" passed to ${methodSignature} must have one of values: ${inspect.supportedChecksumAlgorithms.join(
            ", "
          )}`
        );
      }
      if (options && options.symlinks !== void 0 && inspect.symlinkOptions.indexOf(options.symlinks) === -1) {
        throw new Error(
          `Argument "options.symlinks" passed to ${methodSignature} must have one of values: ${inspect.symlinkOptions.join(
            ", "
          )}`
        );
      }
    };
    var relativePathInTree = (parentInspectObj, inspectObj) => {
      if (parentInspectObj === void 0) {
        return ".";
      }
      return parentInspectObj.relativePath + "/" + inspectObj.name;
    };
    var checksumOfDir = (inspectList, algo) => {
      const hash = crypto.createHash(algo);
      inspectList.forEach((inspectObj) => {
        hash.update(inspectObj.name + inspectObj[algo]);
      });
      return hash.digest("hex");
    };
    var calculateTreeDependentProperties = (parentInspectObj, inspectObj, options) => {
      if (options.relativePath) {
        inspectObj.relativePath = relativePathInTree(parentInspectObj, inspectObj);
      }
      if (inspectObj.type === "dir") {
        inspectObj.children.forEach((childInspectObj) => {
          calculateTreeDependentProperties(inspectObj, childInspectObj, options);
        });
        inspectObj.size = 0;
        inspectObj.children.sort((a, b) => {
          if (a.type === "dir" && b.type === "file") {
            return -1;
          }
          if (a.type === "file" && b.type === "dir") {
            return 1;
          }
          return a.name.localeCompare(b.name);
        });
        inspectObj.children.forEach((child) => {
          inspectObj.size += child.size || 0;
        });
        if (options.checksum) {
          inspectObj[options.checksum] = checksumOfDir(
            inspectObj.children,
            options.checksum
          );
        }
      }
    };
    var findParentInTree = (treeNode, pathChain, item) => {
      const name = pathChain[0];
      if (pathChain.length > 1) {
        const itemInTreeForPathChain = treeNode.children.find((child) => {
          return child.name === name;
        });
        return findParentInTree(itemInTreeForPathChain, pathChain.slice(1), item);
      }
      return treeNode;
    };
    var inspectTreeSync = (path2, opts) => {
      const options = opts || {};
      let tree;
      treeWalker.sync(path2, { inspectOptions: options }, (itemPath, item) => {
        if (item) {
          if (item.type === "dir") {
            item.children = [];
          }
          const relativePath = pathUtil.relative(path2, itemPath);
          if (relativePath === "") {
            tree = item;
          } else {
            const parentItem = findParentInTree(
              tree,
              relativePath.split(pathUtil.sep),
              item
            );
            parentItem.children.push(item);
          }
        }
      });
      if (tree) {
        calculateTreeDependentProperties(void 0, tree, options);
      }
      return tree;
    };
    var inspectTreeAsync = (path2, opts) => {
      const options = opts || {};
      let tree;
      return new Promise((resolve, reject) => {
        treeWalker.async(
          path2,
          { inspectOptions: options },
          (itemPath, item) => {
            if (item) {
              if (item.type === "dir") {
                item.children = [];
              }
              const relativePath = pathUtil.relative(path2, itemPath);
              if (relativePath === "") {
                tree = item;
              } else {
                const parentItem = findParentInTree(
                  tree,
                  relativePath.split(pathUtil.sep),
                  item
                );
                parentItem.children.push(item);
              }
            }
          },
          (err) => {
            if (err) {
              reject(err);
            } else {
              if (tree) {
                calculateTreeDependentProperties(void 0, tree, options);
              }
              resolve(tree);
            }
          }
        );
      });
    };
    exports.validateInput = validateInput;
    exports.sync = inspectTreeSync;
    exports.async = inspectTreeAsync;
  }
});
var require_exists = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/exists.js"(exports) {
    "use strict";
    var fs2 = require_fs();
    var validate = require_validate();
    var validateInput = (methodName, path2) => {
      const methodSignature = `${methodName}(path)`;
      validate.argument(methodSignature, "path", path2, ["string"]);
    };
    var existsSync = (path2) => {
      try {
        const stat = fs2.statSync(path2);
        if (stat.isDirectory()) {
          return "dir";
        } else if (stat.isFile()) {
          return "file";
        }
        return "other";
      } catch (err) {
        if (err.code !== "ENOENT") {
          throw err;
        }
      }
      return false;
    };
    var existsAsync = (path2) => {
      return new Promise((resolve, reject) => {
        fs2.stat(path2).then((stat) => {
          if (stat.isDirectory()) {
            resolve("dir");
          } else if (stat.isFile()) {
            resolve("file");
          } else {
            resolve("other");
          }
        }).catch((err) => {
          if (err.code === "ENOENT") {
            resolve(false);
          } else {
            reject(err);
          }
        });
      });
    };
    exports.validateInput = validateInput;
    exports.sync = existsSync;
    exports.async = existsAsync;
  }
});
var require_copy = (0, import_chunk_2ESYSVXG.__commonJS)({
  "../../node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/copy.js"(exports) {
    "use strict";
    var pathUtil = (0, import_chunk_2ESYSVXG.__require)("path");
    var fs2 = require_fs();
    var dir = require_dir();
    var exists = require_exists();
    var inspect = require_inspect();
    var write = require_write();
    var matcher = require_matcher();
    var fileMode = require_mode2();
    var treeWalker = require_tree_walker();
    var validate = require_validate();
    var validateInput = (methodName, from, to, options) => {
      const methodSignature = `${methodName}(from, to, [options])`;
      validate.argument(methodSignature, "from", from, ["string"]);
      validate.argument(methodSignature, "to", to, ["string"]);
      validate.options(methodSignature, "options", options, {
        overwrite: ["boolean", "function"],
        matching: ["string", "array of string"],
        ignoreCase: ["boolean"]
      });
    };
    var parseOptions = (options, from) => {
      const opts = options || {};
      const parsedOptions = {};
      if (opts.ignoreCase === void 0) {
        opts.ignoreCase = false;
      }
      parsedOptions.overwrite = opts.overwrite;
      if (opts.matching) {
        parsedOptions.allowedToCopy = matcher.create(
          from,
          opts.matching,
          opts.ignoreCase
        );
      } else {
        parsedOptions.allowedToCopy = () => {
          return true;
        };
      }
      return parsedOptions;
    };
    var generateNoSourceError = (path2) => {
      const err = new Error(`Path to copy doesn't exist ${path2}`);
      err.code = "ENOENT";
      return err;
    };
    var generateDestinationExistsError = (path2) => {
      const err = new Error(`Destination path already exists ${path2}`);
      err.code = "EEXIST";
      return err;
    };
    var inspectOptions = {
      mode: true,
      symlinks: "report",
      times: true,
      absolutePath: true
    };
    var shouldThrowDestinationExistsError = (context) => {
      return typeof context.opts.overwrite !== "function" && context.opts.overwrite !== true;
    };
    var checksBeforeCopyingSync = (from, to, opts) => {
      if (!exists.sync(from)) {
        throw generateNoSourceError(from);
      }
      if (exists.sync(to) && !opts.overwrite) {
        throw generateDestinationExistsError(to);
      }
    };
    var canOverwriteItSync = (context) => {
      if (typeof context.opts.overwrite === "function") {
        const destInspectData = inspect.sync(context.destPath, inspectOptions);
        return context.opts.overwrite(context.srcInspectData, 